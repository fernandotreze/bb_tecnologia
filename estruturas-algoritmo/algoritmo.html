<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>O que é um Algoritmo e suas Estruturas</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f5f5f5;
      margin: 0;
      padding: 0 20px;
      line-height: 1.6;
    }
    header, footer {
      background-color: lightgray;
      color: #fff;
      padding: 10px;
      text-align: center;
    }
    main {
      background-color: #fff;
      padding: 20px;
      margin: 20px auto;
      max-width: 800px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    h1, h2, h3 {
      color: #2c3e50;
    }
    pre {
      background: #eef;
      padding: 10px;
      border-left: 4px solid #3498db;
      overflow-x: auto;
    }
    ul {
      margin: 0;
      padding-left: 20px;
    }
    .section {
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <header>
    <h1>O que é um Algoritmo?</h1>
  </header>
  <main>
    <section class="section">
      <h2>Definição de Algoritmo</h2>
      <p>
        Um <strong>algoritmo</strong> é uma sequência finita de instruções ou passos bem definidos, projetados para resolver um problema ou realizar uma tarefa. 
        Ele pode ser implementado em diversas linguagens de programação e consiste em um conjunto de operações que, quando executadas em ordem, produzem um resultado.
      </p>
    </section>

    <section class="section">
      <h2>Grupos de Estruturas Utilizadas em Algoritmos</h2>
      <p>
        Para implementar um algoritmo, utilizamos diversas estruturas de controle que organizam o fluxo de execução. As principais estruturas são:
      </p>
      <ul>
        <li><strong>Estrutura Sequencial:</strong> As instruções são executadas uma após a outra, na ordem em que aparecem.</li>
        <li><strong>Estrutura Condicional:</strong> Permite que o algoritmo tome decisões com base em condições. Exemplos: <code>if</code>, <code>else</code> e <code>switch</code>.</li>
        <li><strong>Estrutura Iterativa (ou de Repetição):</strong> Permite repetir um conjunto de instruções enquanto uma condição for verdadeira. Exemplos: <code>for</code> e <code>while</code>.</li>
        <li><strong>Estrutura Recursiva:</strong> Uma função que se chama a si mesma para resolver um problema, geralmente dividindo-o em subproblemas menores.</li>
      </ul>
    </section>

    <section class="section">
      <h2>Tipos de Algoritmos</h2>
      
      <!-- Algoritmo 1.1 -->
      <h3>Algoritmo 1.1 - Inversão de uma sequência</h3>
      <p>
          O objetivo é inverter a ordem dos elementos de um vetor. A ideia é trocar o primeiro elemento com o último, o segundo com o penúltimo, e assim por diante, percorrendo apenas metade do vetor.
      </p>
      <pre>
Algoritmo 1.1
Inversão de uma sequência
para i := 1, …, ⎣n/2⎦ faça
    temp := S[i]
    S[i] := S[n – i + 1]
    S[n – i + 1] := temp
      </pre>
      <p>
          A notação <code>⎣x⎦</code> (piso de <em>x</em>) indica o maior inteiro menor ou igual a <em>x</em>. Assim, para um vetor com <em>n</em> elementos, se <em>n</em> for ímpar, o elemento central não é alterado.
      </p>
      <p>
          <strong>Exemplo:</strong> Para <code>S = [10, 20, 30, 40, 50]</code>:
      </p>
      <ul>
          <li>Troca do 1º com o 5º elemento: [50, 20, 30, 40, 10]</li>
          <li>Troca do 2º com o 4º elemento: [50, 40, 30, 20, 10]</li>
          <li>O elemento central (30) permanece inalterado.</li>
      </ul>
      
      <h4>Implementação em Python</h4>
      <p>
          Em Python, podemos inverter uma lista de duas formas:
      </p>
        
      <h5>Com Loop Manual</h5>
      <pre>
def inverter_lista(lista):
    n = len(lista)
    for i in range(n // 2):
        # Troca os elementos sem variável temporária usando atribuição múltipla
        lista[i], lista[n - i - 1] = lista[n - i - 1], lista[i]

# Exemplo de uso
lista = [10, 20, 30, 40, 50]
inverter_lista(lista)
print(lista)  # Saída: [50, 40, 30, 20, 10]
      </pre>
        
      <h5>Usando Slicing</h5>
      <pre>
lista = [10, 20, 30, 40, 50]
lista = lista[::-1]
print(lista)  # Saída: [50, 40, 30, 20, 10]
      </pre>
      <p>
          O slicing cria uma nova lista invertida e percorre todos os elementos, enquanto o loop manual modifica a lista original e percorre apenas metade dos elementos.
      </p>
      
      <!-- Algoritmo 1.2 -->
      <h3>Algoritmo 1.2 - Fatorial (recursivo)</h3>
      <p>
          Este algoritmo calcula o fatorial de um número de forma recursiva, utilizando a definição matemática:
      </p>
      <p>
          <strong>Definição:</strong> Para <em>n ≥ 0</em>, se <em>n ≤ 1</em> então <em>n! = 1</em>; senão, <em>n! = n × (n-1)!</em>
      </p>
      <pre>
Algoritmo 1.2
Fatorial (recursivo)
função fat(i)
    fat(i) := se i ≤ 1 então 1 senão i × fat(i – 1)
      </pre>
      <p>
          O algoritmo utiliza a recursividade, onde a função <code>fat</code> se chama repetidamente até atingir o caso base (quando <em>i ≤ 1</em>).
      </p>
      <p>
          <strong>Exemplo:</strong> Para calcular o fatorial de 4:
      </p>
      <ul>
          <li>fat(4) = 4 × fat(3)</li>
          <li>fat(3) = 3 × fat(2)</li>
          <li>fat(2) = 2 × fat(1)</li>
          <li>fat(1) = 1 (caso base)</li>
      </ul>
      <p>
          Assim, 4! = 4 × 3 × 2 × 1 = 24.
      </p>
      <h4>Implementação em Python</h4>
      <pre>
def fatorial_recursivo(n):
    if n <= 1:
        return 1
    else:
        return n * fatorial_recursivo(n - 1)

# Exemplo de uso
print("Fatorial recursivo de 4:", fatorial_recursivo(4))  # Saída: 24
      </pre>
      
      <!-- Algoritmo 1.3 -->
      <h3>Algoritmo 1.3 - Fatorial (não recursivo)</h3>
      <p>
          Este algoritmo calcula o fatorial de um número de forma iterativa, utilizando um vetor para armazenar os resultados parciais.
      </p>
      <pre>
Algoritmo 1.3
Fatorial (não recursivo)
fat[0] := 1
para j := 1, …, n faça
    fat[j] := j × fat[j – 1]
      </pre>
      <p>
          Inicialmente, <code>fat[0]</code> é definido como 1 (pois 0! = 1). Em seguida, para cada <em>j</em> de 1 até <em>n</em>, o algoritmo calcula <code>fat[j]</code> multiplicando <em>j</em> pelo fatorial do número anterior, <code>fat[j-1]</code>.
      </p>
      <p>
          <strong>Exemplo:</strong> Para calcular 4!:
      </p>
      <ul>
          <li>fat[0] = 1</li>
          <li>fat[1] = 1 × fat[0] = 1</li>
          <li>fat[2] = 2 × fat[1] = 2</li>
          <li>fat[3] = 3 × fat[2] = 6</li>
          <li>fat[4] = 4 × fat[3] = 24</li>
      </ul>
      <h4>Implementação em Python</h4>
      <pre>
def fatorial_iterativo(n):
    fat = [1] * (n + 1)
    for j in range(1, n + 1):
        fat[j] = j * fat[j - 1]
    return fat[n]

# Exemplo de uso
print("Fatorial iterativo de 4:", fatorial_iterativo(4))  # Saída: 24
      </pre>
    </pre>
      
    <!-- Algoritmo 1.4 -->
    <h3>Algoritmo 1.4 - Torre de Hanói</h3>
    <p>
        A Torre de Hanói é um problema clássico que ilustra de forma natural e intuitiva o uso da recursividade. 
        Consiste em três pinos: A (origem), B (destino) e C (trabalho), e <em>n</em> discos de tamanhos diferentes empilhados em A em ordem decrescente (o maior na base).
    </p>
    <p>
        <strong>Objetivo:</strong> Mover todos os discos de A para B, obedecendo as restrições:
    </p>
    <ul>
        <li>Apenas um disco pode ser movido de cada vez.</li>
        <li>Nenhum disco pode ser colocado sobre um disco menor.</li>
    </ul>
    <p>
        A solução recursiva para n > 1 envolve três passos:
    </p>
    <ul>
        <li>Mover os n – 1 discos do pino A para o pino C, usando B como auxiliar.</li>
        <li>Mover o disco restante (o maior) de A para B.</li>
        <li>Mover os n – 1 discos de C para B, usando A como auxiliar.</li>
    </ul>
    <pre>
Algoritmo 1.4
Torre de Hanói
procedimento hanoi(n, A, B, C)
  se n > 0 então
      hanoi(n – 1, A, C, B)
      mover o disco do topo de A para B
      hanoi(n – 1, C, B, A)
    </pre>
    <p>
        A chamada externa para iniciar o processo é <code>hanoi(n, A, B, C)</code>.
    </p>
    <h4>Implementação em Python</h4>
    <pre>
def hanoi(n, A, B, C):
  if n > 0:
      hanoi(n - 1, A, C, B)
      print(f"Mover o disco do pino {A} para o pino {B}")
      hanoi(n - 1, C, B, A)

# Exemplo de uso
print("Solução para Torre de Hanói com 3 discos:")
hanoi(3, "A", "B", "C")
    </pre>
    <p>
        Nesta implementação, a função <code>hanoi</code> utiliza recursividade para resolver o problema, 
        imprimindo os movimentos necessários para transferir os discos de A para B.
    </p>      
    </section>
  </main>
  <footer>
    <p>&copy; 2025 Aprendizado TI</p>
  </footer>
</body>
</html>
